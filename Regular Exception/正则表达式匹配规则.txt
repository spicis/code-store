出处：http://blog.csdn.net/zaifendou/article/details/5746988	侵删

/d		任意一个数字，0-9中的任意一个
/w		任意一个字母或数字或下划线，也就是A-Z,a-z,0-9,_中任意一个
/s		包括空格、制表符、换页符等空白字符的其中任意一个
.		小数点可以匹配除了换行符（/n）以外的任意一个字符

[ab5@]		匹配"a"或"b"或"5"或"@"
[^abc]		匹配"a","b","c"之外的任意一个字符
[f-k]		匹配"f"-"k"之间的任意一个字母
[^A-F0-3]	匹配"A"-"F","0"-"3"之外的任意一个字符

{n}		表达式重复n次
{m, n}		表达式至少重复m次，最多重复n次
{m,}		表达式至少重复m次
?		匹配表达式0次或者1次，相当于{0， 1}
+		表达式至少出现1次，相当于{1,}
*		表达式不出现或出现任意次，相等于{0,}

^		与字符串开始的地方匹配，不匹配任何字符
$		与字符串结束的地方匹配，不匹配任何字符
/b		匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符
		以上三个表达式不是很明白！！！

|		左右两边表达式之间“或”关系，匹配左边或者右边
()		(1).在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰
		(2).取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到

正则表达式的一些高级规则
贪婪模式
总是尽可能多的匹配
文本"dxxxdxxxd"
(d)(/w+)	"/w+"将匹配第一个"d"之后的所以字符"xxxdxxxd"
(d)(/w+)(d)	"/w+"将匹配第一个"d"和最后一个"d"之间的所以字符"xxxdxxx"。虽然"/w+"也能够匹配上最后一个"d"，但是为了使整个表达式匹配成功，"/w+"可以“让出”它本来能够匹配的最后一个"d"

非贪婪模式
在匹配次数的特殊符号后再加上一个"?"
尽可能的少匹配，也叫勉强模式
文本"dxxxdxxxd"
(d)(/w+?)	"/w+"将尽可能少的匹配第一个"d"之后的字符，结结果是："/w+?"只匹配了一个"x"
(d)(/w+?)(d)	为了让整个表达式匹配成功，"/w+?"不得不匹配"xxx"才可以让后边的"d"匹配，从而使整个表达式匹配成功。因此，结果		是："/w+?"匹配"xxx"

反向引用
/1，/2		表达式引擎会将小括号"()"包含的表达式所匹配到的字符串记录下来。匹配到的字符串可以单独获取，不仅实在匹配结束后可以使用，在匹配过程中也可以使用。按"("先后排序。

正向预搜索："(?=xxxxx)"，"(?!xxxxx)"
		格式："(?=xxxxx)"，在被匹配的字符串中，它对所处的 "缝隙" 或者 "两头" 附加的条件是：所在缝隙的右侧，必须能够匹配上 xxxxx 这部分的表达式。因为它只是在此作为这个缝隙上附加的条件，所以它并不影响后边的表达式去真正匹配这个缝隙之后的字符。这就类似 "/b"，本身不匹配任何字符。"/b" 只是将所在缝隙之前、之后的字符取来进行了一下判断，不会影响后边的表达式来真正的匹配。
		格式："(?!xxxxx)"，所在缝隙的右侧，必须不能匹配 xxxxx 这部分表达式。

反向预搜索："(?<=xxxxx)"，"(?<!xxxxx)"
		这两种格式的概念和正向预搜索是类似的，反向预搜索要求的条件是：所在缝隙的 "左侧"，两种格式分别要求必须能够匹配和必须不能够匹配指定表达式，而不是去判断右侧。与 "正向预搜索" 一样的是：它们都是对所在缝隙的一种附加条件，本身都不匹配任何字符。

/xXX		(X表示一个16进制数)编号在 0-255 范围的字符，比如：空格可以使用 "/x20" 表示
/uXXXX		任何字符可以使用 "/u" 再加上其编号的4位十六进制数表示，比如："/中"

/S		匹配所有非空白字符
/D		匹配所有的非数字字符
/W		匹配所有的字母、数字、下划线以外的字符
/B		匹配非单词边界，即左右两边都是"/w"范围或者左右两边都不是"/w"范围时的字符缝隙

一下字符需要加上"/"转移才能匹配字符本身
^	$	()	[]	{}	.	?	+	*	|

如果希望匹配结果不进行记录供以后使用，可以使用"(?:xxxxx)"格式

常用的表达式属性设置简介：Ignorecase，Singleline，Multiline，Global
Ignorecase	默认情况下，表达式中的字母是要区分大小写的。配置为 Ignorecase 可使匹配时不区分大小写。有的表达式引擎，把 "大小写" 概念延伸至 UNICODE 范围的大小写。
Singleline	默认情况下，小数点 "." 匹配除了换行符（/n）以外的字符。配置为 Singleline 可使小数点可匹配包括换行符在内的所有字符。
Multiline	默认情况下，表达式 "^" 和 "$" 只匹配字符串的开始 ① 和结尾 ④ 位置。如：
①xxxxxxxxx②/n
③xxxxxxxxx④
配置为 Multiline 可以使 "^" 匹配 ① 外，还可以匹配换行符之后，下一行开始前 ③ 的位置，使 "$" 匹配 ④ 外，还可以匹配换行符之前，一行结束 ② 的位置。
Global		主要在将表达式用来替换时起作用，配置为 Global 表示替换所有的匹配。

其他提示
4.1 如果想要了解高级的正则引擎还支持那些复杂的正则语法，可参见本站 DEELX 正则引擎的说明文档。

4.2 如果要要求表达式所匹配的内容是整个字符串，而不是从字符串中找一部分，那么可以在表达式的首尾使用 "^" 和 "$"，比如："^/d+$" 要求整个字符串只有数字。

4.3 如果要求匹配的内容是一个完整的单词，而不会是单词的一部分，那么在表达式首尾使用 "/b"，比如：使用 "/b(if|while|else|void|int……)/b" 来匹配程序中的关键字。

4.4 表达式不要匹配空字符串。否则会一直得到匹配成功，而结果什么都没有匹配到。比如：准备写一个匹配 "123"、"123."、"123.5"、".5" 这几种形式的表达式时，整数、小数点、小数数字都可以省略，但是不要将表达式写成："/d*/.?/d*"，因为如果什么都没有，这个表达式也可以匹配成功。更好的写法是："/d+/.?/d*|/./d+"。

4.5 能匹配空字符串的子匹配不要循环无限次。如果括号内的子表达式中的每一部分都可以匹配 0 次，而这个括号整体又可以匹配无限次，那么情况可能比上一条所说的更严重，匹配过程中可能死循环。虽然现在有些正则表达式引擎已经通过办法避免了这种情况出现死循环了，比如 .NET 的正则表达式，但是我们仍然应该尽量避免出现这种情况。如果我们在写表达式时遇到了死循环，也可以从这一点入手，查找一下是否是本条所说的原因。

4.6 合理选择贪婪模式与非贪婪模式，参见话题讨论。

4.7 或 "|" 的左右两边，对某个字符最好只有一边可以匹配，这样，不会因为 "|" 两边的表达式因为交换位置而有所不同。

